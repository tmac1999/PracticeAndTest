package com.gaosi.view.paintcode;

/**
 * Created by mrz on 2018/12/6.
 */

import android.graphics.BlurMaskFilter;
import android.graphics.Canvas;
import android.graphics.Color;
import android.graphics.Paint;
import android.graphics.Path;
import android.graphics.PorterDuff;
import android.graphics.PorterDuffXfermode;
import android.graphics.RectF;



/**
 * Created by AuthorName on Dec 6, 2018.
 * Copyright Â© 2018 CompanyName. All rights reserved.
 * <p>
 * Generated by PaintCode
 * http://www.paintcodeapp.com
 *
 * @author AuthorName
 */
public class StyleKitName {
    private static class GlobalCache {
        static PorterDuffXfermode blendModeSourceIn = new PorterDuffXfermode(PorterDuff.Mode.SRC_IN);
    }

    // Resizing Behavior
    public enum ResizingBehavior {
        AspectFit, //!< The content is proportionally resized to fit into the target rectangle.
        AspectFill, //!< The content is proportionally resized to completely fill the target rectangle.
        Stretch, //!< The content is stretched to match the entire target rectangle.
        Center, //!< The content is centered in the target rectangle, but it is NOT resized.
    }

    // Canvas Drawings
    // Tab

    private static class CacheForCanvas1 {
        private static Paint paint = new Paint();
        private static Paint shadowPaint = new Paint();
        private static PaintCodeShadow shadow = new PaintCodeShadow();
        private static RectF originalFrame = new RectF(0f, 0f, 240f, 120f);
        private static RectF resizedFrame = new RectF();
        private static RectF ovalRect = new RectF();
        private static Path ovalPath = new Path();
    }

    public static void drawCanvas1(Canvas canvas) {
        StyleKitName.drawCanvas1(canvas, new RectF(0f, 0f, 240f, 120f), ResizingBehavior.AspectFit);
    }

    public static void drawCanvas1(Canvas canvas, RectF targetFrame, ResizingBehavior resizing) {
        // General Declarations
        Paint paint = CacheForCanvas1.paint;

        // Local Colors
        int shadowColor = Color.argb(255, 35, 59, 120);

        // Local Shadows
        PaintCodeShadow shadow = CacheForCanvas1.shadow.get(PaintCodeColor.colorByChangingAlpha(shadowColor, (int) (Color.alpha(shadowColor) * 0.08f * 255f)), 0f, 4f, 10f);

        // Resize to Target Frame
        canvas.save();
        RectF resizedFrame = CacheForCanvas1.resizedFrame;
        StyleKitName.resizingBehaviorApply(resizing, CacheForCanvas1.originalFrame, targetFrame, resizedFrame);
        canvas.translate(resizedFrame.left, resizedFrame.top);
        canvas.scale(resizedFrame.width() / 240f, resizedFrame.height() / 120f);

        // Oval
        RectF ovalRect = CacheForCanvas1.ovalRect;
        ovalRect.set(81f, 27f, 131f, 77f);
        Path ovalPath = CacheForCanvas1.ovalPath;
        ovalPath.reset();
        ovalPath.addOval(ovalRect, Path.Direction.CW);

        paint.reset();
        paint.setFlags(Paint.ANTI_ALIAS_FLAG);
        canvas.saveLayerAlpha(null, 255, Canvas.ALL_SAVE_FLAG);
        {
            canvas.translate(shadow.dx, shadow.dy);

            Paint shadowPaint = CacheForCanvas1.shadowPaint;
            shadowPaint.set(paint);
            shadow.setBlurOfPaint(shadowPaint);
            canvas.drawPath(ovalPath, shadowPaint);
            shadowPaint.setXfermode(GlobalCache.blendModeSourceIn);
            canvas.saveLayer(null, shadowPaint, Canvas.ALL_SAVE_FLAG);
            {
                canvas.drawColor(shadow.color);
            }
            canvas.restore();
        }
        canvas.restore();
        paint.setStyle(Paint.Style.FILL);
        paint.setColor(Color.WHITE);
        canvas.drawPath(ovalPath, paint);

        paint.reset();
        paint.setFlags(Paint.ANTI_ALIAS_FLAG);
        paint.setStrokeWidth(3f);
        paint.setStrokeMiter(10f);
        canvas.save();
        paint.setStyle(Paint.Style.STROKE);
        paint.setColor(Color.WHITE);
        canvas.drawPath(ovalPath, paint);
        canvas.restore();

        canvas.restore();
    }

    // Tab 2

    private static class CacheForCanvas2 {
        private static RectF originalFrame = new RectF(0f, 0f, 240f, 120f);
        private static RectF resizedFrame = new RectF();
    }

    public static void drawCanvas2(Canvas canvas) {
        StyleKitName.drawCanvas2(canvas, new RectF(0f, 0f, 240f, 120f), ResizingBehavior.AspectFit);
    }

    public static void drawCanvas2(Canvas canvas, RectF targetFrame, ResizingBehavior resizing) {
        // Resize to Target Frame
        canvas.save();
        RectF resizedFrame = CacheForCanvas2.resizedFrame;
        StyleKitName.resizingBehaviorApply(resizing, CacheForCanvas2.originalFrame, targetFrame, resizedFrame);
        canvas.translate(resizedFrame.left, resizedFrame.top);
        canvas.scale(resizedFrame.width() / 240f, resizedFrame.height() / 120f);

        // Empty.

        canvas.restore();
    }


    // Resizing Behavior
    public static void resizingBehaviorApply(ResizingBehavior behavior, RectF rect, RectF target, RectF result) {
        if (rect.equals(target) || target == null) {
            result.set(rect);
            return;
        }

        if (behavior == ResizingBehavior.Stretch) {
            result.set(target);
            return;
        }

        float xRatio = Math.abs(target.width() / rect.width());
        float yRatio = Math.abs(target.height() / rect.height());
        float scale = 0f;

        switch (behavior) {
            case AspectFit: {
                scale = Math.min(xRatio, yRatio);
                break;
            }
            case AspectFill: {
                scale = Math.max(xRatio, yRatio);
                break;
            }
            case Center: {
                scale = 1f;
                break;
            }
        }

        float newWidth = Math.abs(rect.width() * scale);
        float newHeight = Math.abs(rect.height() * scale);
        result.set(target.centerX() - newWidth / 2,
                target.centerY() - newHeight / 2,
                target.centerX() + newWidth / 2,
                target.centerY() + newHeight / 2);
    }


}

class PaintCodeColor extends Color {
    private static float[] ColorToHSV(int originalColor) {
        float hsv[] = new float[3];
        RGBToHSV(red(originalColor), green(originalColor), blue(originalColor), hsv);
        return hsv;
    }

    public static int colorByChangingHue(int originalColor, float newHue) {
        float hsv[] = ColorToHSV(originalColor);
        hsv[0] = newHue;
        return HSVToColor(alpha(originalColor), hsv);
    }

    public static int colorByChangingSaturation(int originalColor, float newSaturation) {
        float hsv[] = ColorToHSV(originalColor);
        hsv[1] = newSaturation;
        return HSVToColor(alpha(originalColor), hsv);
    }

    public static int colorByChangingValue(int originalColor, float newValue) {
        float hsv[] = ColorToHSV(originalColor);
        hsv[2] = newValue;
        return HSVToColor(alpha(originalColor), hsv);
    }

    public static float hue(int color) {
        return ColorToHSV(color)[0];
    }

    public static float saturation(int color) {
        return ColorToHSV(color)[1];
    }

    public static float brightness(int color) {
        return ColorToHSV(color)[2];
    }

    public static int colorByChangingAlpha(int color, int newAlpha) {
        return argb(newAlpha, red(color), green(color), blue(color));
    }

    public static int colorByBlendingColors(int c1, float ratio, int c2) {
        return argb((int) ((1f - ratio) * alpha(c1) + ratio * alpha(c2)),
                (int) ((1f - ratio) * red(c1) + ratio * red(c2)),
                (int) ((1f - ratio) * green(c1) + ratio * green(c2)),
                (int) ((1f - ratio) * blue(c1) + ratio * blue(c2)));
    }

    public static int colorByApplyingHighlight(int color, float ratio) {
        return colorByBlendingColors(color, ratio, colorByChangingAlpha(WHITE, alpha(color)));
    }

    public static int colorByApplyingShadow(int color, float ratio) {
        return colorByBlendingColors(color, ratio, colorByChangingAlpha(BLACK, alpha(color)));
    }
}

class PaintCodeShadow {
    int color;
    float dx, dy;
    private float radius;
    private BlurMaskFilter blurMaskFilter;

    PaintCodeShadow() {

    }

    PaintCodeShadow(int color, float dx, float dy, float radius) {
        this.get(color, dx, dy, radius);
    }

    PaintCodeShadow get(int color, float dx, float dy, float radius) {
        this.color = color;
        this.dx = dx;
        this.dy = dy;

        if (this.radius != radius) {
            this.blurMaskFilter = null;
            this.radius = radius;
        }

        return this;
    }

    void setBlurOfPaint(Paint paint) {
        if (this.radius <= 0)
            return;

        if (this.blurMaskFilter == null)
            this.blurMaskFilter = new BlurMaskFilter(this.radius, BlurMaskFilter.Blur.NORMAL);

        paint.setMaskFilter(this.blurMaskFilter);
    }
}

